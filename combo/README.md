# Аккорды

Данный модуль позволяет вам задавать аккорды любой длины, причём в отличие от стандартной фичи [combos](https://docs.qmk.fm/#/feature_combo) в QMK, данный модуль способен посылать любые кейкоды. Причём данные аккорды способны работать не только в качестве "нажал-отпустил", а качестве зажимаемых клавиш, будь то переключение слоя или модификатор.

Аккорд срабатывает в следующих случаях:
* Если вы зажимаете клавиши для аккорда более 100 миллисекунд, то считается что вы больше не нажмёте клавиш для следующего аккорда, и кейкод текущего аккорда нажимается. Например, можно задать на клавише `CMB_001` аккорд из одной этой клавиши, который при срабатанывании будет нажимать `KC_BSPC` (Backspace), таким образом если вы зажмёте клавишу `CMB_001`, то у вас сначала будет ожидание 100мс, затем нажмётся клавиша Backspace, и начнёт стираться текст. То есть клавиши для аккордов можно свободно использовать даже для клавиш, которые предполагается зажимать, а не только нажать и отпускать.
* Если вы во время зажатия аккорда нажимаете другую клавишу, то считается что вы больше не нажмёте клавиш для следующего аккорда, и кейкод текущего аккорда нажимается.

Если вы хотите более подробно понять как работает обработка аккордов, или хотите модифицировать код, смотрите секцию [принцип работы](#принцип-работы).

Советую вам не бояться нажимать две клавиши одним пальцем, и помещать на такие нажатия аккорды.

# Как использовать?

Приготовьтесь, использовать довольно сложно, потому что данный модуль построен на костылях и хаках (если придумаете как сделать иначе - делайте MR!).

Последовательность действий буедт описана так, чтобы вы модифицировали свой файл `keymap.c` сверху-вниз.

## Задать характеристики

В `config.h` нужно прописать задание следующих переменных, модифицируя их под свои нужды:

* `#define COMBO_KEYS_COUNT 5` - количество используемых клавиш для аккордов, для данной опции у вас в итоге получатся клавиши `CMB_000`, `CMB_001`, ... , `CMB_004`.
* `#define COMBO_MAX_SIZE 3` - максимальное количество одновременно зажимаемых клавиш для одного аккорда, больше этого размера аккорд задавать нельзя.
* `#define COMBO_STACK_MAX_SIZE 3` - максимальное количество одновременно зажимаемых аккордов. То есть, например, у вас есть аккорд для получения шифта, вы его зажимаете, затем вы нажимаете другой аккорд один раз, это значит что максимально у вас было 2 одновременно зажатых аккорда. 3 должно хватить для всех целей.
* `#define COMBO_WAIT_TIME 100` - время в миллисекундах в течении которого ждётся что все клавиши текущего аккорда будут нажаты. Если это время истекло, и текущую комбинацию нажатых клавиш можно трактовать как аккорд, то именно эта комбинация и пошлётся.
* `#define COMBO_LAYER 4` - слой, на котором будут находиться нажимаемые клавиши для аккордов, об этом подробнее потом. Рекомендуется создать отдельный слой для этого, и разместить его самым последним.
* `#define COMBO_COUNT 10` - количество аккордов, которое вы будете использовать.

Так же необходимо включить опцию `STRICT_LAYER_RELEASE` в `config.h`, иначе будет такой баг, что когда позиция кейкода для аккорда будет совпадать с одновременно нажимаемой клавишей, то клавиша аккорда не отожмётся...

## Подключение кода

В своём файле `keymap.c` в самом верху подключаем файл `combo/code.c`:
```c
#include "combo/code.c"
```

## Написать какие аккорды существуют

Далее надо записать какие комбинации зажатых клавиш для аккордов будут иметь место, записываются они при помощи макроса `CHORD` следующим образом:

```c
const ComboKey combos[COMBO_COUNT][COMBO_MAX_SIZE + 1] = {
  CHORD(0),
  CHORD(1),
  CHORD(2),
  CHORD(3),
  CHORD(4),
  CHORD(0, 1),
  CHORD(0, 2),
  CHORD(1, 2),
  CHORD(3, 4),
  CHORD(0, 1, 2),
};
```

Здесь можно указывать аккорды в любом порядке, не обязательно по возрастанию количества клавиш и по возрастанию чисел внутри аккорда.

## Поместить аккорды на вашу раскладку

Используйте кейкоды `CMB_000`-`CMB_XXX` (зависит сколько вы задали их в начале файла).

```c
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    //---------------------------------------------------------------------------
  [0] = MY_layout(
    // ...
    XXXXXXX,    XXXXXXX,  XXXXXXX,  CMB_003,  CMB_004,
    CMB_002,
    CMB_000,    CMB_001,  KC_ENT,
    // ...
  ),
  // ...
```

## Задать каждому аккорду кейкод

Именно здесь уже начинаются костыли. Из-за невозможности просто вызвать функцию для нажатия произвольного кейкода, будь то `TG(4)` или ваш кастомный кейкод, приходится прибегать к такой эмуляции, что как будто после срабатывания аккорда мы на самом деле нажимаем клавишу из слоя клавиатуры.

Нужно внутри объявления раскладки, в переменной `keymaps` создать в самом конце слой, который не будет использовать макрос `keyboard`, а будет напрямую задаваться в виде набора строк и столбцов. Здесь клавиши нумеруются слева-направо, сверху-вниз. Нужно для каждого номера аккорда написать какая клавиша будет нажата для него.

```c
[4] = {
  { SHF_1_O, KC_BSPC, KC_LCTL, KC_SLSH, KC_UP,   SHF_1,   XXXXXXX },
  { KC_DEL,  MO(2),   KC_E,    XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX },
  { XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX }
},
```

То есть для такого слоя и для опсания аккордов из предыдущего пункта получаем следующую картину:
* Для аккорда `CMB_000` будет нажата клавиша `SHF_1_O`
* `CMB_001` - `KC_BSPC`
* `CMB_002` - `KC_LCTL`
* `CMB_003` - `KC_SLSH`
* `CMB_004` - `KC_UP`
* Для аккорда с одновременно нажатыми `CMB_000` + `CMB_001` получаем кейкод `SHF_1`
* `CMB_000` + `CMB_002` - `XXXXXXX` (не будет нажато ничего) (такой пустой аккорд не обязательно задавать)
* `CMB_003` + `CMB_004` - `MO(2)` (включаем слой на время зажатия этого аккорда)
* `CMB_000` + `CMB_001` + `CMB_002` - `KC_E`.

## Вызов модуля для каждой клавиши

В функции `process_record_user` в самом начале, перед всеми проверками, добавляем код обработки аккорда:
```c
bool process_record_user(uint16_t key, keyrecord_t *record) {
  if (combo_enabled && !combo_process(keycode, record))
    return false;

  // ...
}
```

Затем нужно определить функцию `matrix_scan_user`, если она у вас ещё не определена, и вызывать функцию `user_timer`, а в этой функции вызывать `combo_user_timer();`:
```c
void user_timer(void) {
  combo_user_timer();
}

void matrix_scan_user(void) {
  user_timer();
}
```

**Объяснение:** функция `matrix_scan_user` вызывается примерно каждые 2 миллисекунды, она сканирует матрицу. Значит её вполне можно использовать для отслеживания собственных таймеров. Поэтому мы вызываем из неё функцию `user_timer`, которая лучше говорит о наших намерениях, чем `matrx_scan_user`. А уже в функции `user_timer` мы вызываем обработку случая когда мы слишком долго держим аккорд.

# Модифицировать код qmk

```diff
diff --git a/quantum/keymap_common.c b/quantum/keymap_common.c
index 570d4798d..a3536ce16 100644
--- a/quantum/keymap_common.c
+++ b/quantum/keymap_common.c
@@ -179,7 +179,11 @@ __attribute__((weak)) void action_function(keyrecord_t *record, uint8_t id, uint
 // translates key to keycode
 __attribute__((weak)) uint16_t keymap_key_to_keycode(uint8_t layer, keypos_t key) {
     // Read entire word (16bits)
-    return pgm_read_word(&keymaps[(layer)][(key.row)][(key.col)]);
+    if (key.use_custom_keycode) {
+        return key.custom_keycode;
+    } else {
+        return pgm_read_word(&keymaps[(layer)][(key.row)][(key.col)]);
+    }
 }
 
 // translates function id to action
diff --git a/tmk_core/common/action.c b/tmk_core/common/action.c
index aa1a2999e..503ddf510 100644
--- a/tmk_core/common/action.c
+++ b/tmk_core/common/action.c
@@ -741,6 +741,7 @@ void process_action(keyrecord_t *record, action_t action) {
  * FIXME: Needs documentation.
  */
 void register_code(uint8_t code) {
+    // uprintf("-----------   register: %d\n", code);
     if (code == KC_NO) {
         return;
     }
@@ -837,6 +838,7 @@ void register_code(uint8_t code) {
  * FIXME: Needs documentation.
  */
 void unregister_code(uint8_t code) {
+    // uprintf("-----------UN register: %d\n", code);
     if (code == KC_NO) {
         return;
     }
diff --git a/tmk_core/common/keyboard.h b/tmk_core/common/keyboard.h
index ff7736718..59ff1c893 100644
--- a/tmk_core/common/keyboard.h
+++ b/tmk_core/common/keyboard.h
@@ -29,6 +29,8 @@ extern "C" {
 typedef struct {
     uint8_t col;
     uint8_t row;
+    bool use_custom_keycode;
+    uint16_t custom_keycode;
 } keypos_t;
 
 /* key event */
```

# Принцип работы

![](dka.png)

Здесь показано как работает обработка аккордов. Оранжевые прямоугольники показывают условиях перехода; белые показывают ждущие состояния; зелёные показывают действия. В белых прямоугольниках подписан номер состояния, которое хранится в `combo->state`, а в оранжевых подписана буква перехода, которую можно найти в коде по использованию макроса `TRANSITION_DEBUG()`.

Данный конечный автомат показывает обработку для одного аккорда, находящегося в стэке. Порядок обработки следующий:
* Сначала обрабатываем все аккорды в стэке согласно этому ДКА, если хотя бы один сработал, завершаем всю обработку.
* Если ни один не сработал, то обрабатываем текущую клавишу синим прямоугольником.

Таким образом мы можем добавлять новые аккорды в стэк если они не добавляют ничего к уже зажатым, и можем добавлять к зажатым ещё клавиш, если в итоге можно что-то нажать.
